# 第4章 数据结构



常用数据结构



![img](v2-eeee188ae49d391248564e1de93ba1e9_720w.jpg)



#### java常见数据结构的时间复杂度

![img](1091200-20190528130816356-1027047999.jpg)

## **1.栈**

图示

![img](v2-9300d8234d0d440eef0582248ed267fc_720w.jpg)



核心方法

◎ push()：向栈中压入一个数据，先入栈的数据在最下边。

◎ pop()：弹出栈顶数据，即移除栈顶数据。

◎ peek()：返回当前的栈顶数据。

栈结构



![img](v2-66cae88babdeeb4caf7e9b03f7fd8829_720w.jpg)



![img](v2-6aadfbae18c07a884a731aee71bf3603_720w.jpg)



入栈



![img](v2-25f9abe9a56d64637afe057d6f74db80_720w.jpg)



出栈



![img](v2-57838467b9f0aaf8f05a0bcf5d60bfc8_720w.jpg)



查找元素



![img](v2-8291eee32724fd59f2f58e699465d75a_720w.jpg)



## **2.队列**

FIFO-first in first out 线性表



![img](v2-00def2709bf871dc6390668552e35ee6_720w.jpg)





**核心方法：**

◎ add()：向队列的尾部加入一个元素（入队），先入队列的元素在最前边。

◎ poll()：删除队列头部的元素（出队）。

◎ peek()：取出队列头部的元素。

队列结构



![img](v2-62bcf943ee963329896ff9a658436b0f_720w.jpg)



入队



![img](v2-61d457ff490994bee7cfa2b91b5d14c3_720w.jpg)



出队



![img](v2-6281fbd4d511459309d8b9f2721752be_720w.jpg)



查对头



![img](v2-bfe5d21845c1cda1d5a14636ee157576_720w.jpg)



## **3.链表**

链表有 3 种：单向链表、双向链表及循环链表。



![img](v2-51e80c6b20259a0a58c4e1cdcdcf593b_720w.jpg)



### **3.1.单链表**

链接方向单向，访问链表时要从头部开始顺序读取。

一个单向链表的节点（Node）可分为两部分：第 1 部分为数据区（data），用于保存节点的数据信息；第 2 部分为指针区，用于存储下一个节点的地址，最后一个节点的指针指向 null。



![img](v2-b59d10947ddf9be9a16006c65dfdefad_720w.jpg)



**单链表操作**

查找

插入



![img](v2-1aab4203d2d0d66b677bf3dce3931050_720w.jpg)



删除



![img](v2-78afe7ed116de454fc50a81219404bfc_720w.jpg)



单链表结构



![img](v2-d7be46a042849b285c0a676ec7a634f5_720w.jpg)



插入



![img](v2-e801a420e4fbe2036969ad2366b21987_720w.jpg)



删除



![img](v2-c5bdbfc25e6032a3959149d4264d71cf_720w.jpg)



![img](v2-57d8d634261aec2f66b1c5493cd372c3_720w.jpg)



查询

![img](v2-1164ec0ab56dba27fde88fc004e5d77e_720w.jpg)



### **3.2.双向链表**

每个数据节点中都有两个指针，分别指向其直接后继和直接前驱节点。



![img](v2-4f5def4d7ecd7de4c96c5226861ec0e3_720w.jpg)



结构



![img](v2-2a5c5c6ce193b6c3a0d1fb21e81def7e_720w.jpg)

![img](v2-350a3c1ad96cabcf97c486a5af1b5a9d_720w.jpg)



头部增加节点

![img](v2-f32272e7194dc2737b221e139f47abbe_720w.jpg)



尾部增加节点



![img](v2-c2fa98db26866896f2543c706b44dd2d_720w.jpg)

![img](v2-bb2b78a320a8472154e572ec719cc3bc_720w.jpg)



删除头节点

![img](v2-0ae3e87939597f2c6215d245d52f23d8_720w.jpg)



删除尾节点

![img](v2-bce739140a335022cdaf8a1a124d595b_720w.jpg)

![img](v2-4f35d00de451238fd50f1f885b092137_720w.jpg)



### **3.3.循环链表**

表中最后一个节点的指针域指向头节点，整个链表形成一个环。



![img](v2-0aca1dd3411d2311eaccedada7d2cee0_720w.jpg)



## **4.哈希表**

根据数据的关键码值（Key-Value 对）对数据进行存取的数据结构。



![img](v2-f816ce188ace26a76d69fb5292e3e6b5_720w.jpg)



### **4.1.计算散列算法**

◎ 直接定址法：取关键字或关键字的某个线性函数值为散列地址，即 *h*（key）= key 或*h*（key）=a×key+b，其中 a 和 b 为常数。

◎ 平方取值法：取关键字平方后的中间几位为散列地址。

◎ 折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。

◎ 除留余数法：取关键字被某个不大于散列表长度 *m*的数 p 除后所得的余数为散列地址，即*h*(key)=key/p (p≤*m*)。

◎ 随机数法：选择一个随机函数，取关键字的随机函数值作为其散列地址，即*h*(key)=random(key)。

◎ Java HashCode 实现：在 Java 中计算 HashCode 的公式为 *f*(key) = s[0] × 31n-1+s[1] × 31n-2 +...+*s*[*n*-1]。具体实现如下：



![img](v2-dc68ba84882e5517823f7ac58a15a48f_720w.jpg)

![img](v2-32e10b248e8bd3837289b38ba0b91e2d_720w.jpg)



### **4.2.Hash应用**

◎ 信息安全：Hash 主要被用于信息安全领域的加密算法中

◎ 快速查找：散列表，又叫作散列，是一种更加快捷的查找技术。

## **5.二叉查找树**

满足以下条件的树：

◎ 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；

◎ 若右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；

◎ 左、右子树也分别为二叉排序树。



![img](v2-3c741cffc5d2f450f3c7dbdeefe00cef_720w.jpg)



### **5.1.插入**

（1）将待插入的新节点与当前节点进行比较，如果两个节点的值相同，则表示新节点已经存在于二叉排序树中，直接返回 false。

（2）将待插入的新节点与当前节点进行比较，如果待插入的新节点的值小于当前节点的值，则在当前节点的左子树中寻找，直到左子树为空，则当前节点为要找的父节点，将新节点插入当前节点的左子树即可。

（3）将待插入的新节点与当前节点进行比较，如果待插入的新节点的值大于当前节点的值，则在当前节点的右子树中寻找，直到右子树为空，则当前节点为要找的父节点，将新节点插入当前节点的右子树即可。



![img](v2-d440ebef47f613ed4fc7d0de418e1990_720w.jpg)



### **5.2.删除**

删除操作主要分为三种情况：待删除的节点没有子节点；待删除的节点只有一个子节点；待删除的节点有两个子节点。

（1）在待删除的节点没有子节点时，直接删除该节点，即在其父节点中将其对应的子节点置空即可。要删除的节点 14 没有子节点，则直接将其删除即可。



![img](v2-f759d92fbc84043c7e3b8180f44e1ec4_720w.jpg)



（2）在待删除的节点只有一个子节点时，使用子节点替换当前节点，然后删除该节点即可。要删除的节点 5 有一个子节点 8，则使用子节点 8 替换需要删除的节点 5，然后删除节点 5 的数据即可。



![img](v2-c7883d4867463a85262deeccf470839e_720w.jpg)



（3）在待删除的节点有两个子节点时，首先查找该节点的替换节点（替换节点为左子树中的最大节点或者右子树中的最小节点），然后替换待删除的节点为替换节点，最后删除替换节点。要删除的节点 4 有两个子节点，其左子树最小的节点为 2，其右子树最小的节点为 5，因此有两种结果。



![img](v2-3f32eb856a4139d4b3158eb54dac0d40_720w.jpg)



### **5.3.查找**

接近二分查找法。将要查找的数据与根节点的值进行比较，如果相等就返回，如果小于就到左子树中递归查找，如果大于就到右子树中递归查找。

### **5.4.实现**

结构



![img](v2-bdaf0fee9c94a20acc4a55e61c14fde6_720w.jpg)





![img](v2-36a568dabdf1b1b0391944937bcf626e_720w.jpg)



插入



![img](v2-e4c39e192004365e6a00464c4c5395fa_720w.jpg)





![img](v2-8f3af64495d406681d1e591bbf2bc6d3_720w.jpg)



删除



![img](v2-74e1adedd3a6b0fe8c27b54fa3e6d980_720w.jpg)





![img](v2-f63ee741fde160b496c756b23d1056fd_720w.jpg)



查询



![img](v2-ec66c5cf0585441b129731d8c10850fd_720w.jpg)



## **6.红黑树**

自平衡的二叉查找树。在红黑树的每个节点上都多出一个存储位表示节点的颜色，颜色只能是红或者黑。

### **6.1.特性**

◎ 每个节点或者是黑色的，或者是红色的。

◎ 根节点是黑色的。

◎ 每个叶子节点（NIL）都是黑色的。

◎ 如果一个节点是红色的，则它的子节点必须是黑色的。

◎ 从一个节点到该节点的子孙节点的所有路径上都包含相同数量的黑色节点。

结构



![img](v2-1b248f1d16086212a21e7219c20a55f3_720w.jpg)



### **6.2.左旋**

对 a 节点进行左旋，指将 a 节点的右子节点设为 a 节点的父节点，即将 a 节点变成一个左节点。因此左旋意味着被旋转的节点将变成一个左节点



![img](v2-3f95ad7c98c1d3fe37653890b7f65718_720w.jpg)



### **6.3.右旋**

对 b 节点进行右旋，指将 b 节点的左子节点设为 b 节点的父节点，即将 b 节点设为一个右节点。因此右旋意味着被旋转的节点将变成一个右节点



![img](v2-12cd84c21ec1e63fd23d1197c150d063_720w.jpg)



### **6.4.添加**

分为 3 步：① 将红黑树看作一颗二叉查找树，并以二叉树的插入规则插入新节点；② 将插入的节点涂为「红色」或「黑色」；③ 通过左旋、右旋或着色操作，使之重新成为一颗红黑树。

### **6.5.删除**

分为两步：① 将红黑树看作一颗二叉查找树，根据二叉查找树的删除规则删除节点；② 通过左旋、旋转、重新着色操作进行树修正，使之重新成为一棵红黑树

## **7.图**

图是由有穷非空集合的顶点和顶点之间的边组成的集合，通常表示为 G（V,E），其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。

### **7.1.无向图**

从顶点 V*i*到 V*j*的边没有方向，则称这条边为无向边。顶点和无向边组成的图为无向图



![img](v2-dce71ce748c2692151b32cb4f5952686_720w.jpg)



从顶点 V*i*到 V*j*的边有方向，则称这条边为有向边，也叫作弧，用有序偶 <V*i*,V*j*> 来表示有向边，V*i*叫作弧尾，V*j*叫作弧头。由顶点和有向边组成的图叫作有向图。



![img](v2-d0b352d797cfd1d11e60ec172203e3e5_720w.jpg)



### **7.2.存储结构：邻接矩阵**

图的邻接矩阵的存储方式是基于两个数组来表示图的数据结构并存储图中的数据。一个一维数组存储图中的顶点信息，一个二维数组（叫作邻接矩阵）存储图中的边或弧的信息。设图 G 有*n*个顶点，则邻接矩阵是一个*n*×*n*的方阵



![img](v2-81d0036649d984b11bfb7db139583216_720w.jpg)





**1. 无向图的邻接矩阵**

在无向图的邻接矩阵中，如果 <V*i*,V*j*> 的交点为 1，则表示两个顶点连通，为 0 则不连通。在无向图的邻接矩阵中，主对角元素都为 0，也就是说顶点自身没有连通关系



![img](v2-1a34d2f7b2c0fc1c116eb04de734c3fb_720w.jpg)



**2.有向图的邻接矩阵**

在有向图的邻接矩阵中，如果 <V*i*,V*j*> 的交点为 1，则表示从 V*i*到 V*j*存在弧（但从 V*j*到 V*i*是否存在弧不确定），为 0 则表示从 V*i*到 V*j*不存在弧；同样，在有向图的邻接矩阵中主对角元素都为 0，也就是说从顶点到自身没有弧。需要注意的是，有向图的连接是有方向的，V1的出度为 2（从 V1出发的边有两条），表示从 V1顶点出发的边有两条，V3的出度为 0，表示没有从 V3出发的边。



![img](v2-79a98f930713771abcac84e547f584ca_720w.jpg)



**3. 带权重图的邻接矩阵**

有些图的每条边上都带有权重，如果要将这些权值保存下来，则可以采用权值代替矩阵中的 0、1，在权值不存在的元素之间用 ∞ 表示



![img](v2-1c6c562d521abd1a1789c483ee28e897_720w.jpg)



### **7.3.存储结构：邻接矩阵**

数组与链表相结合的存储方法叫作邻接表。

**1. 无向图的邻接表结构**

顶点是通过一个头节点类型的一维数组保存的，其中每个头节点的第 1 个弧都指向第 1 条依附在该顶点上的边的信息，邻接域表示该边的另一个顶点在顶点数组中的下标，下一个弧指向下一条依附在该顶点上的边的信息。



![img](v2-9d9f2c6b79108bb897b9d8c0606b69bd_720w.jpg)



**2. 带权值的网图连接表结构**

对于带权值的图，在节点定义中再增加一个权重值 weight 的数据域，存储权值信息即可



![img](v2-8e26a20b4a6c7682ddf0d6b78fde68d8_720w.jpg)



### **7.4.图的遍历**

图的遍历指从图中某一顶点出发访遍图中的每个顶点，且使每一个顶点仅被访问一次。图的遍历分为广度优先遍历和深度优先遍历

**1. 广度优先遍历**

假设从图中某个顶点 V 出发，在访问了 V 之后依次访问 V 的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直到图中所有已被访问的顶点的邻接点都被访问；若此时图中尚有顶点未被访问，则另选图中未曾被访问的一个顶点作为起始点重复上述过程，直至图中所有顶点均被访问。



![img](v2-1c79ecee9f5d27d3c44684990c770249_720w.jpg)



**2. 深度优先遍历**

假设从图中的某个顶点 V 出发，在访问 V 节点后依次从 V 未被访问的邻接点出发以深度优先的原则遍历图，直到图中所有和 V 节点路径连通的顶点都被访问；若此时图中尚有顶点未被访问，则另选一个未曾访问的顶点作为起始点重复上述过程，直至图中所有节点都被访问。



![img](v2-3983207a8ceaeb5c5eb4696c1f60357a_720w.jpg)





## **8.位图**

基于数组实现，将数组中的每个元素都看作一系列二进制数，所有元素一起组成更大的二进制集合，这样就可以大大节省空间。

### **8.1.位图的数据结构**

位图在内部维护了一个*M*×*N*维的数组 char[M][N]，在这个数组里面每个字节占 8 位，因此可以存储 *M*×*N*×8 个数据。假如要存储的数据范围为 0～15，则只需使用 M=1，N=2 的数据进行存储



![img](v2-5917c2e8b4dc9f0c2c154f7fed5f1a0f_720w.jpg)



在我们要存储的数据为{1,3,6,10,15}时，只需将有数据的位设置为 1，表示该位存在数据，将其他位设置为 0



![img](v2-561c7cf9dc7eae93dc94eef1c094546f_720w.jpg)



### **8.2.实现**

结构



![img](v2-f12d93c9e875dfb6c4ac70207ca65052_720w.jpg)



查询



![img](v2-3f8673791d4b5dbbc23bea89d8b5fa02_720w.jpg)



修改



![img](v2-4e3d816c56c2c3b772fd4c1179560896_720w.jpg)



## **9.总结**



![img](v2-3a9b97ce086fd0e498de82a01f6efe0d_720w.jpg)